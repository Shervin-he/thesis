\cchapter{مقدمه}
\par
امنیت در رای‌گیری همواره یک مسئله‌ی پیچیده بوده است که نیازمند یک فرد قابل اعتماد برای برگزاری و یک پروتکل امن برای جلوگیری از تقلب یا اشتباه در فرایند آن است. سیستم‌های رای‌گیری الکترونیک 

از سال ۱۹۶۰ وجود داشتند و اولین استفاده‌ بزرگ از آن‌ها در چند ایالت آمریکا در سال ۱۹۶۴ برای انتخابات ریاست جمهوری بود. رای‌گیری الکترونیک به‌سادگی می‌تواند هزینه برگزاری انتخابات را از طریق سادگی شمارش کاهش دهد. 

\section{فرایند رای‌گیری ایده‌آل}

شروط فرایند رای‌گیری ایده‌آل عبارت‌ است از:
\begin{itemize}
	\item 
	هر فرد واجد شرایط دقیقا یک بار بتواند رای دهد.
	\item 
	هیچ کسی نتواند به جای فرد دیگری رای دهد.
	\item 
  	هیچ فردی مجبور به رای دادن نشود.
  	\item 
  	هیچ فردی مجبور به رای دادن به کاندیدای خاصی نشود.
  	\item 
  	از شمارش هر رای اطمینان حاصل شود.
  	\item 
    نتیجه‌ی آرا ناشناس  باقی بماند. 
  	\item 
  	بسته به نیاز بتوان نتایج لحظه‌ای انتخابات را (بدون آسیب به شرط‌های قبلی) دید.
\end{itemize}

\section{سیستم‌های رای‌گیری سنتی}
\par
در رای‌گیری غیر الکترونیکی معمولا فرایند به شکل زیر است:
\\
فرد برای رای‌دادن به یکی از حوزه‌های رای‌گیری مراجعه کرده و با ارائه‌ی مدارک شناسایی خود یک برگه‌ی رای دریافت می‌کند. برگه رای دارای دو بخش است: قسمتی که برای ردیابی با اطلاعات شخصی فرد پر می‌شود و یک قسمت بی‌نام که فرد کاندیدای مورد نظر خود را در آن ثبت کرده و در یک صندوق می‌اندازد. 
\\
با بررسی مدارک شناسایی، شرط دوم فرایند رای‌گیری ایده‌آل تایید شده و با ثبت شدن اطلاعات فرد به عنوان یک رای‌دهنده از رای دادن دوباره‌ی او جلوگیری می‌شود. امنیت شخصی افراد در حوزه توسط برگزارکننده‌ی انتخابات تامین می‌شود و با وجود گزینه‌ی «رای سفید» فردی مجبور به رای دادن و یا رای دادن به یک کاندیدای خاص نمی‌شود. 
\\
با وجود یک صندوق برای چندین رای و نبودن هیچ نشانه‌ی شناسایی در آرا، هیچ راهی برای فهمیدن رای یک فرد خاص - حتی اگر برگه‌های رای به دست رقیب بیفتد - وجود ندارد. 
\\
احزار هویت و شمارش رای‌ها به عهده‌ی برگزارکننده‌ی انتخابات است و تنها از طریق یک شخص ثالث برای باز‌شماری آرا می‌توان از اجرای درست آن‌ها اطمینان حاصل کرد.
\\
با توجه به هزینه‌ی زیاد شمارش در انتخابات‌های بزرگ راهی برای اعلام لحظه‌ا‌ی نتایج با هزینه‌ی معقول وجود ندارد.
\\
همانطور که می‌بینیم در روش‌های فعلی انتخابات بسیاری از شرایط مورد نیاز یک انتخابات خوب  با هزینه‌ی نسبتا زیاد فراهم می‌شود. از دیگر مشکلات انتخابات به این روش می‌توان به نیازمندی به یک برگزارکننده‌ی مورد اعتماد اشاره کرد. باید به برگزارکننده اعتماد شود تا: 
\begin{enumerate}
	\item 
	امنیت حوزه‌ی انتخابات را تامین کند.
	\item 
	افراد را به درستی احراز هویت کند.
	\item 
	همه‌ی رای‌ها را بشمارد.
	\item 
	تغییری در رای‌ها ندهد.
	
\end{enumerate}
 

\section{مشکلات و چالش‌های رای‌گیری الکترونیک}
\par
دو مسئله‌ی اساسی در یک سیستم رای‌گیری امنیت و حریم خصوصی است. مخالفین رای‌گیری الکترونیک از کم هزینه بودن تقلب و تغییر رای‌های ثبت شده در انتخابات الکترونیکی می‌گویند و رد کاغذی در یک انتخابات را یک فاکتور مهم برای امنیت آن می‌دانند. هزینه تغییر میلیون‌ها رای در یک سیستم کامپیوتری بسیار پایین‌تر از تولید چند میلیون رای کاغذی تقلبی برای تغییر نتیجه‌ی یک انتخابات است.
\\
بزرگترین مسئله در به‌کارگیری رای‌گیری الکترونیک مسئله‌ی اعتماد به یک سیستم‌ کامپیوتری است. از نظر بسیاری از رای‌دهندگان رای دادن با کامپیوتر شخصی می‌تواند ریسک تغییر رای تا رسیدن آن به سرور‌های رای‌گیری ایجاد کند. از طرف دیگر عدم امکان بررسی و تایید انسانی عملیات کامپیوتر، حس امنیت کمتری القا می‌کند.
\par
مسئله‌ی دیگر پرهزینه بودن ساخت زیرساخت‌های رای‌گیری الکترونیک و خطر پیدایش مشکلات امنیتی در هر سیستم کامپیوتری - چه از نظر نرم‌افزار و چه سخت‌افزار - است. این مشکل باعث شده تعدادی از کشور‌ها از جمله هلند، ایرلند و آلمان فرایند ایجاد زیرساخت لازم را شروع کرده و در ادامه این فرایند را ملقی کنند. دلیل اصلی اعلام شده برای این مسائل‌ قابل اتکا نبودن سیستم‌های رای‌گیری الکترونیکی اعلام شده است. 
\\
برای مثال یک تحقیق معروف از دانشگاه‌ \lr{NYU} در سال ۲۰۱۵ 
\LTRfootnote{https://www.brennancenter.org/publication/americas-voting-machines-risk}
توضیح داد که ماشین‌های رای‌گیری الکترونیکی که در ۴۳ ایالت آمریکا استفاده می‌شوند در سال ۲۰۱۶ به دهمین سال استفاده شدن می‌رسند و به دلیل نداشتن بودجه‌ی کافی برای تعمیرات و بروزرسانی، در معرض خطر کرش
\LTRfootnote{crash}
 کردن هستند که می‌تواند باعث کندی فرایند و حتی گاها از دست رفتن را‌ی‌های مردم شود. علاوه بر این، قدیمی بودن دستگاه‌ها می‌تواند ریسک‌های امنیتی ایحاد کند. 

\par
یک مشکل دیگر در پیاده‌سازی‌های بسیاری از رای‌گیری الکترونیک، نیاز به اینترنت و توانایی استفاده از کامپیوتر است. این مسئله می‌تواند دسترسی بسیاری از افرادی واجد شرایط را - به دلیل نقص جسمی و یا عدم توانایی کار با کامپیوتر - محدود کند. در سیستم‌های فعلی که مبتنی بر حوزه‌های رای‌گیری هستند می‌توانند با کمک انسانی در خود حوزه تا حدی این مشکلات را رفع کنند. 
\par
مشکلات مطرح‌ شده موانع بزرگی برای فراگیری سیستم‌های رای‌گیری کاملا الکترونیکی برای انتخابات‌های مهم و بزرگ هستند که یک سیستم رای‌گیری مناسب باید آن‌ها را تا جای ممکن رفع کند. 

\section{انگیزه و هدف}
هدف این تحقیق، طراجی یک سیستم رای‌گیری الکترونیک است که شرایط رای‌گیری ایده‌آل را تا جای ممکن بدون نیاز به اعتماد به شخص ثالث ایفا کند. با فراگیری تکنولوژی بلاک‌چین برای ایچاد سیستم‌های توزیع شده بدون نیاز به اعتماد (برای مثال بیت‌کوین به عنوان یک‌ ارز دیجیتال بدون نیاز به اعتماد)، پلتفرم‌هایی برای رای‌گیری الکترونیک ایجاد شدند که امنیت شمارش آرا را با عمومی ساختن فرایند رای‌گیری تامین می‌کردند. 
\\
با وجودی که راه‌حل ارائه شده‌ی این سیستم‌ها مسئله‌ی اطمینان از شمارش رای‌ها را حل می‌کرد، مسئله‌ی حریم شخصی در این روش‌ها حل نشده است و انتخابات‌های برگزار شده با این سیستم‌ها امنتیت کمتری در قبال ناشناس ماندن رای‌ها ارائه می‌کنند. 
\\
برای مثال حالتی را فرض کنید که یک رای‌دهنده تهدید می‌شود که باید به یک کاندیدای خاص رای بدهد، در سیستم‌های سنتی رای‌گیری به دلیل بی‌نام بودن برگه‌های رای بعد از اتمام فرایند رای‌گیری راهی برای اطمینان حاصل کردن از نتیجه‌ی رای فرد نیست. از طرفی به دلیل امنیت حوزه‌های رای‌گیری راهی برای اطمینان از نتیجه‌ی رای یک نفر در حین فرایند رای‌گیری هم نیست. پس راهی برای محبور کردن یک نفر که به یک کاندیدای خاص رای بدهد وجود ندارد. اما در سیستم‌های مبتنی بر بلاک‌چین هر رای داده شده به امضای الکترونیکی فرد امضا شده است و این موضوع می‌تواند با عمومی شدن بلاک‌چین بعد از رای‌گیری باعث لو رفتن نتیجه‌ی رای آن فرد شود.
\\
این مشکلات مانع بزرگی برای استفاده‌ی فراگیر این سیستم‌ها خواهد بود. هدف ما در این تحقیق ارائه امنیت و هزینه‌ی کم ناشی از استفاده از این روش‌های رای‌گیری، بدون ایجاد ریسک‌های جدید در حریم خصوصی رای‌دهندگان است. 
\par
نتیجه‌ی این تحقیق یک سیستم‌ رای‌گیری الکترونیک است که قیاس با سیستم‌های سنتی انتخابات هزینه‌ها را کاهش خواهد داد. در عین حال کمترین تغییر برای رای‌دهندگان خواهد داشت که باعث افزایش دسترس‌پذیری این سیستم خواهد شد. همچنین تمامی آرا رای‌دهندگان در قبال یک مهاجم خارجی و حتی خود برگزار کننده‌ی انتخابات ناشناس خواهند ماند. 
\\
از طرفی این سیستم یک رد الکترونیک غیرقابل انکار از تمام ارا، در قبال یک بلاک‌چین، ارائه ‌خواهد کرد که توانایی اثبات درستی شمارش را برای شخص ثالث بدون ایجاد خطری برای ناشناسی رای‌ها خواهد داد. 
\\
تمامی این قابلیت‌ها بدون نیاز اعتماد به برگزارکننده‌ی انتخابات خواهد بود و هرگونه تخطی از پروتکل ارائه شده توسط حوزه‌های رای‌گیری قابل ردیابی از طریق اطلاعات ثبت شده در بلاک‌چین خواهد بود.








\cchapter{تعریف مفاهیم}
در این بخش به معرفی بعضی مفاهیم پایه برای این تحقیق می‌پردازیم. در ابتدا با مفاهیم بلاک‌چین و انواع و کاربرد‌های آن آشنا می‌شویم و در ادامه به بررسی اثبات‌های بی‌دانش می‌پردازیم. این دو تکنولوژی ابزارهای تئوری لازم برای ساخت سیستم رای‌گیری امن خواهند بود.
\section{بلاک‌چین}
بلاک‌چین ساختمان‌داده‌ایست که به مانند لینک‌‌لیست
\LTRfootnote{Linked list}
از بلوک‌‌های متوالی تشکیل شده ولی در بلاک‌چین هر بلوک هش
\LTRfootnote{Hash}
عنصر قبلی خود را نیز نگه‌می‌دارد. هدف از این کار ساخت یک ساختار داده‌ی صرفا افزایشی 
\LTRfootnote{Append only}
است که در آن‌ بلوک‌های قبلی تغییرناپذیرند. تغییر هر بلوک باعث تغییر بلوک بعدی خواهد شد و این موضوع تشخیص تغییر در بلوک‌های پیشین را بسیار ساده می‌کند.
\section{درخت مرکل}


برای پیاده‌سازی یک بلاک‌چین معمولا از درخت مرکل
 \LTRfootnote{Merkle tree}
 استفاده‌ می‌شود. درخت مرکل یا درخت هش، نوعی درخت دودویی 
 \LTRfootnote{Binary tree}
 است که در آن هر راس هش فرزندان خود را نگه‌داشته و برگ‌ها هش داده‌ی ذخیره‌شده در خودشان را نگه می‌دارند. این روش نگه‌داری اطلاعات باعث می‌شود که درچه‌ی زمانی بررسی وجود یک بلوک داده در بلاک‌چین از 
 \lr{N}
 به 
$ \log N$
 کاهش یابد. به دلیل این نوع ساختار یک درخت مرکل، هر تغییری در درخت باعت تغییر هش در ریشه‌ی آن خواهد شد و به دلیل رندم بودن خروچی یک هش خوب، هش ریشه‌ی درخت مرکل هیچ ویژگی قابل پیشبینیی ندارد.
 
 \begin{figure}[th!]
 	\centering
 	\includegraphics[width=.7\linewidth]{Hash_Tree.png}
 	\caption {یک درخت مرکل}
 	\label{fig:merkle}
 \end{figure}
 
 \subsection{انواع بلاک‌چین}
 در این تحقیق بلاک‌چین‌ها را از دو نظر دسته‌‌بندی می‌کنیم. بلاک‌چین‌ها می‌توانند عمومی یا خصوصی باشند، در بلاک‌چین‌های عمومی اضافه‌کردن بلوک به بلاک‌چین دسترسی خاصی نمی‌خواهد و هر کسی می‌تواند در آن‌ها بنویسد ولی در بلاک‌چین‌های خصوصی اضافه کردن بلوک صرفا توسط افراد خاص ممکن است. 
 \\
 روش دیگر تقسیم‌بندی ما باز یا بسته بودن بلاک‌چین است که این دسته‌بندی در مورد دسترسی خواندن اطلاعات از بلاک‌چین است. در بلاک‌چین‌های بسته خواندن اطلاعات توسط عموم آزاد نیست و در بلاک‌چین‌های خصوصی تمام اطلاعات بلاک‌چین برای خواندن، در دسترس عموم است. 
\par
با توجه به کاربرد بلاک‌چین مورد نظر هر بلاک‌چین می‌تواند در هر کدام از این دسته‌بندی‌ها قرار بگیرد، جدول  \ref{tab:tch} یک کاربرد ممکن برای هر کدام از این دسته‌بندی‌ها را نشان می‌دهد.

\begin{table}[h]
	\begin{center}
		%		\def\arraystretch{2}
		\caption{انواع بلاک‌چین}
		\begin{tabular}{|c|c|c|}
			\hline
			& باز & بسته \\
			\hline
			عمومی & ارز‌های دیجیتال & بعضی رای‌گیری‌ها \\
			\hline
			خصوصی & سامانه‌ی مدیریت اطلاعات مالیات & اطلاعات خصوصی یک شرکت \\
			\hline

		\end{tabular}
		\label{tab:tch}
	\end{center}
\end{table}


 
 
\section{اثبات‌های بی‌دانش}
اثبات‌ بی‌دانش 
\LTRfootnote{Zero knowledge proofs}
روشی است که یک «اثبات‌کننده» می‌تواند یه یک «بررسی‌کننده» نشان دهد که او یک راز - مثلا خروجی یک عملیات کامپیوتری - را می‌داند، بدون این که به بررسی‌کننده هیچ اطلاعات اضافه‌ای، مانند خروجی عملیات، بدهد. به عبارت دیگر اثبات‌های بی‌دانش، صرفا داشتن اطلاعات را اثبات می‌کنند و خود اطلاعات را محفوظ نگه‌ می‌دارند.
\\
یک اثبات بی‌دانش باید ۳ شرط زیر را داشته باشد:
\begin{itemize}
	\item
	کامل‌بودن: اگر گزاره‌ی مورد اثبات صحیح باشد، بررسی‌کننده‌ای که پروتکل را رعایت کند، باید از درستی گزاره مطمئن شود.
	\item 
	درستی: اگر گزاره مورد اثبات غلط باشد، هیچ اثبات‌کننده‌ای نتواند اثباتی ارائه کند که گزاره درست است. 
	\item 
	بی‌دانش: اگر اثبات درست باشد، بررسی کننده هیچ اطلاعاتی فراتر از این که گزاره صحیح است دریافت نکند.
\end{itemize}
اثبات‌های بی‌دانش، اثبات‌های احتمالاتی هستند و در واقع احتمال کمی وجود دارد که بتوان یک اثبات نادرست ارائه کرد. به بیان دیگر شرط درستی این است که احتمال تولید یک اثبات نادرست بسیار کم باشد. 
\subsection{مثال شهودی}
سناریویی را در نظر می‌گیریم که یک توپ سبز و یک توپ قرمز روی یک میز قرار دارد و آلیس می‌خواهد به باب که کوررنگ سبز و قرمز است ثابت کند که که این دو توپ با هم تفاوت دارند. برای اثبات آلیس چشمش را می‌بندد و باب یا دو توپ را جابجا می‌کند و یا جابجا نمی‌کند. در ادامه آلیس می‌گوید که آیا جای توپ‌ها با هم عوض شده‌اند یا نه. با یک پاسخ درست باب می‌فهمد که آلیس با احتمال ۵۰٪ درست می‌گوید. این فرایند را تا جایی که باب به احتمال دلخواهش برسد ادامه می‌دهند.
\par
یک نکته‌ی مهم در مثال بالا این است که حتی اگر باب این فرایند را ضبط کرده باشد، نمی‌تواند به کس دیگری اثبات کند که آلیس تفاوت این دو توپ را می‌داند چون که راهی برای اثبات این که سوال و جواب از قبل هماهنگ نشده بوده است ندارد. 
\\
این یکی از نیازمندی‌های بی‌دانش بودن اثبات است. اگر در فرایند برای تصمیم‌گیری در تعویض توپ‌ها باب از شیر یا خط کردن یک سکه استفاده می‌کرد، دیگر این اثبات بی‌دانش نبود، چرا که باب می‌توانست با ضبط کردن این فرایند به یک شخص ثالث اثبات کند که آلیس تفاوت این دو توپ را می‌داند. 
\\
برای داشتن شرط بالا یک اثبات بی‌دانش همواره تعامل از سمت بررسی‌کننده نیاز دارد. اما با ریلکس کردن این شرط و استفاده از یک ورودی غیرقابل پیشبینی برای تولید سوال‌های یک اثبات بی‌دانش - مثلا هش ریشه‌ی یک درخت مرکل - می‌توان اثبات‌های بی‌دانش بدون نیاز به تعامل بررسی‌کننده ساخت. 


\subsection{اثبات‌های بی‌دانش بدون تعامل} 
منظور از اثبات بدون تعامل، اثباتی‌ است که در آن نیازی به فرستادن پیامی از سمت بررسی‌کننده به اثبات‌کننده نباشد. با این روش‌ها اثبات‌کننده می‌تواند اثبات را مستقل از بررسی‌کننده بسازد و ارسال کند، در ادامه‌ی این تحقیق اثبات‌های بی‌دانش و بی‌تعامل را 
\textbf{شاهد}
می‌نامیم. در ادامه دو روش تولید یک شاهد بی‌دانش را بررسی می‌کنیم. این روش‌ها می‌توانند برای خروجی هر محاسبات کامپیوتری شاهد ایجاد کنند. 

\subsubsection{ZK-SNARK}
این روش مخفف
\lr{Zero-Knowledge Succinct Non-Interactive Argument of Knowledge}
است. شاهد‌های این روش علاوه بر بی‌دانش بودن ویژگی‌های زیر را دارند:
\begin{itemize}
	\item 
	مختصر
	\LTRfootnote{Succinct}
	: تولید و بررسی شاهد از انجام خود محاسباتی که اثبات می‌شود کوتاه‌تر (معمولا از مرتبه‌ی زمانی $ (\log N) ^ 2$) است. 
	\item
	بی‌تعامل
	\LTRfootnote{Non-Interactive}
	: نیازی به پیامی از بررسی‌کننده برای ایجاد شاهد نیست. 
	\item
	ادعای دانش
	\LTRfootnote{Argument of Knowledge}
	: اثبات ارائه شده در این روش درست 
	\LTRfootnote{Sound}
	است و نمی‌شود بدون داشتن اطلاعات آن را در زمان محدود ساخت.
	
\end{itemize}
 
\begin{figure}[bh]
	\centering
	\includegraphics[width=.5\linewidth]{arithmetic-circuit.png}
	\caption {یک نمونه مدار محاسباتی}
	\label{fig:arithmetic}
\end{figure}

برای ساختن یک شاهد به این روش ابتدا محاسبات لازم را به یک مدار محاسباتی ریاضی تبدیل می‌کنیم به طوری که اثبات را به عنوان تعدادی شرط روی این مدار نشان دهیم، سپس به کمک یک
\lr{elliptic curve}
مقدار مدار را در چند نقطه‌ی تصادفی به عنوان اثبات ارائه می‌کنیم، با صادق بودن شرط‌ها در این نقاط شاهد را بررسی می‌کنیم. 
\\
برای انتخاب یکسان این نقاط تصادفی بین اثبات‌کننده و بررسی‌کننده نیاز به تعدادی نقطه‌ی توافق شده روی \lr{elliptic curve} داریم که باید در قبل از تولید اثبات انتخاب شده باشند. در این فاز آماده‌سازی تعدادی عدد تصادفی برای انتخاب این نقاط تولید می‌شوند که بعد از تولید نقاط باید بلافاصله پاک شوند. کسی که این اعداد (در واقع نقطه‌ی شروع روی منحنی) را داشته باشد می‌تواند شاهد‌های تقلبی ایجاد کند. برای تولید شاهد واقعی نیازی به دانستن این نقاط نیست و بنابراین بعد از فاز آماده‌سازی این اعداد باید پاک شوند. 
\subsubsection{ZK-STARK}
این روش مخفف
\lr{Zero-Knowledge Scalable Transparent ARguments of Knowledge}
است. مهم‌ترین وجه تمایز این روش در مقایسه با
\lr{ZK-SNARK}
 «شفافیت»
 \LTRfootnote{Transparency}
است، به این معنی که نیازی به فاز آماده‌سازی ندارد. عدم نیاز به آماده‌سازی و نداشتن زباله‌ی سمی (اطلاعاتی که باید پاک شوند تا امنیت سیستم تامین شود) این روش را برای کاربرد‌های حساس مناسب‌تر می‌کند اما در ازای این امنیت، حجم شاهد‌ها از چند صد بایت به چند صد هزار بایت تغییر می‌کند.
\par
ار مزیت‌های دیگر این روش استفاده نکردن از 
\lr{Elliptic curve}ها
است. نیاز‌های کم این روش باعث می‌شود که حتی با کامپیوتر‌های کوانتمی
\LTRfootnote{Quantum computers}
 راهی برای شکستن این اثبات‌ها وجود نداشته باشد.
\\
برای ساختن یک شاهد با این روش، برنامه‌ی مورد نظر را تبدیل یه یک چندچمله‌ای درجه بالا می‌کنند، سپس از مقدایر این چندجمله‌ای یک درخت مرکل ساخته می‌شود که مقدایر مختلف خروچی را نشان می‌دهد. سپس بررسی‌کننده چند شاخه از این درخت را به طور تصادفی انتخاب و بررسی می‌کند. برای غیرتعاملی کردن این اثبات می‌توان از هش ریشه‌ی درخت مرکل به عنوان ورودی یه تابع شبه‌تصادفی
\LTRfootnote{Pseudo random}
استفاده می‌شود که مشخص می‌کند خروجی کدام شاخه‌ها باید در شاهد بیاید. 





\cchapter{کارهای پیشین}
در این بخش ابتدا به بررسی تحقیقاتی می‌پردازیم که به مسئله‌ی حدف اعتماد از سیستم‌های مبتنی بر اعتماد پرداخته‌اند، در ادامه به کارهای مربوط به رای‌گیری الکترونیک و در نهایت به اثبات‌های بی‌دانش می‌پردازیم.

\section{اعتماد}
مسئله‌ی حذف نیاز به یک شخص معتمد را از طریق عمومی ساختن کل اطلاعات مورد نیاز می‌توان حل کرد. اگر تمامی اطلاعات درست باشد هر کسی می‌تواند برای خود درستی تراکنش‌ها را بررسی کند. مسئله‌ای که باقی می‌ماند زمانیست که بین چند شخص اختلاف پیش می‌آید که نسخه‌ی درست اطلاعات کدام است. مثلا زمانی که چند نسخه‌ی صحیح از نظر فرمت وجود دارند اما نتایج مختلفی را می‌رسانند. 
\subsection{توافق}
توصیف رسمی این مسئله، مسئله‌ی ژنرال‌های بیزنتین 
\LTRfootnote{The Byzantine genarals problem}
\cite{byzantine}
است. در این مسئله چند ژنرال که می‌توانند یک به یک با هم صحبت کنند، در تلاشند تا به توافق برسند که آیا باید حمله کنند یا نکنند، تعدادی از ژنرال‌ها خائن هستند و در تلاشند که نتیجه‌ی توافق ژنرال‌ها را تغییر دهند. ژنرال‌های خائن می‌توانند با جواب ندادن یا جواب غلط دادن تلاش کنند که نتیجه‌ی توافق را تغییر دهند. در ساده‌ترین حالت و بدون استفاده از امضا‌های دیجیتال ثابت می‌شود که برای $ 3k + 1 $ ژنرال، با رای‌گیری می‌توان تا $ k $ خائن را تحمل کرد. 
\par
راه‌حل‌های متعددی برای توافق 
\LTRfootnote{اثبات‌ کار}
در بستر بلاک‌چین داده شده که در ادامه به تعدادی از آن‌های می‌پردازیم.
\subsubsection{توافق}
روشی که 
\lr{S.Nakomoto}
\cite{bitcoin}
برای رفع این مسئله در بیت‌کوین استفاده کرده است، اثبات کار 
\LTRfootnote{Proof of work}
نام دارد. این روش که بر پایه‌ی روش استفاده شده در 
\lr{hashcash}
\cite{hashcash}
است. در این روش برای اضافه شدن هر بلوک به بلاک‌چین باید یک مسئله‌ی سخت (که نیاز به توان پردازشی بالا دارد) حل شود ولی بررسی درستی جواب ساده است. این روش روش بسیار فراگیری در ارز‌های دیجیتال است. از مشکلات این روش می‌توان به توان مصرفی بالا و کندی نسبی آن اشاره کرد. برای مثال حداکثر توان تئوری بیت‌کوین، ۷ تراکنش بر ثانیه است. 
\subsubsection{اثبات سهم}
در روش اثبات سهم
\LTRfootnote{proof of stake}
\cite{PoS}
برای ساخت بلوک‌های جدید باید یک فاکتور مقدار سکه‌های در اختیار ماینتر و سن آن‌هاست. به این صورت که می‌تواند در ازای سن‌ سکه‌های در اختیارش (با زدن یه تراکنش به خود) هش ساده‌تری برای بلوک بعدی اعمال کند. مزیت اصلی این روش توان مصرفی پایین‌تر آن به نسبت اثبات کار است. 
\\
معمولا در بلاک‌چین‌ها در بلوک‌های ابتدایی ار روش اثبات کار استفاده می‌شود و بعد از مدتی برای کاهش هزینه‌های اضافه کردن بلوک چدید و مقایس‌پذیری می‌توان از این روش یا ترکیب این روش‌ها استفاده کرد.

\subsubsection{Ripple Consensus Protocol}
در این روش
\cite{ripple} \cite{ripple2}
 تعدادی شخص مورد اعتماد وجود دارند که برای اضافه‌شدن بلوک به بلاک‌چین باید درصدی از آن‌ها درستی تراکنش را تایید کنند. این اشخاص در دسته‌های مختلف قرار می‌گیرند و برای تایید باید یک زیردسته‌ی کامل تراکنش‌ها را تایید کنند.
 \\
 با وجود سرعت نسبتا بالای این روش - تا ۱۰۰۰ تراکنش در ثانیه - منتقدین آن از نیاز به اشخاص مورد اعتماد می‌گویند. این روش تا $ n /5 $ خطا در نود‌های مورد اعتماد را می‌تواند تحمل کند.


\subsubsection{Stellar Consensus Protocol}
 روش 
\lr{SCP}
\cite{scp}
 مبتنی بر ایجاد افراد مورد اعتماد، به صورت طبیعی و خودجوش، در شبکه است. در این روش با افزایش تراکنش‌های درست توسط هر شخصی، آن شخص به عنوان فرد مورد اعتماد شناخته می‌شود و هر تراکنش را باید تعداد افراد مورد اعتماد تایید کنند. این افراد توسط پرداخت‌کننده‌ی تراکنش انتخاب می‌شوند اما دسته‌بندی آن‌ها در شبکه‌ به گونه‌ای است که خطا در تایید تراکنش باعث حذف شدن فرد از لیست افراد مورد اعتماد شود. تفاوت اصلی این روش با 
 \lr{Ripple}
 در توانایی انتخاب تاییدکنندگان تراکنش است و فرض‌های اعتماد کمتر این روش باعث می‌شود که تا $ n /3 $ خطا در نود‌های مورد اطمینان را بتواند تحمل کند.



\subsection{کاربرد‌های بلاک‌چین}
\subsubsection{ارز دیجیتال}
اولین کاربرد بلاک‌چین، بیت‌کوین بود که با موفقیت آن چندین مجصول دیگر هم تولید شدند. 
در بستر بیت‌کوین اثبات کار به صورت زیر استفاده می‌شود.:
\\
هر بلوک جدید شامل تعدادی تراکنش، برای ثبت در بلاک‌چین است. اما برای پذیرفته شدن این بلوک توسط دیگر دیگران، باید در این بلاک یک رشته‌ي بی‌معنی 
\LTRfootnote{Nounce}
قرار گیرد به صورتی که هش بلاک از عددی که توسط پروتکل بیت‌کوین انتخاب می‌شود کمتر باشد. این شرط در طول زمان به صورت خودکار به روزرسانی می‌شود به طوری که در هر لحظه به صورت میانگین اضافه کردن یک بلوک ۱۰ دقیقه از کل شبکه زمان ببرد. از آنجایی که تنها راه یافتن همچین رشته‌ای بروت‌فورس
\LTRfootnote{Bruteforce}
است، توان محاسباتی بالاتر احتمال یافتن بلوک بعدی را افزایش خواهد داد. 
\par
در پروتکل بیت‌کوین طولانی‌ترین بلاک‌چین - یعنی بلاک‌چینی که بیشترین توان محاسباتی برای آن صرف شده - به عنوان نسخه‌ی درست در نظر گرفته می‌شود. در نتیجه 
فرض می‌کنیم شخص A یک بیت‌کوین را به B منتقل کرده، این تراکنش در بلاک‌چین ثبت شده و در ازای آن کالایی دریافت کرده‌است، حال قصد دارد این تراکنش را از بلاک‌چین بیت‌کوین حذف کند تا بتواند آن را دوباره خرج کند. از آنجایی که نود‌های شبکه‌ی بیت‌کوین اگر ۲ زنجیره از بلوک‌ها دریافت کنند زنجیره‌ی بلند‌تر را قبول خواهند کرد باید قبل از این که کل شبکه یک بلوک  اضافه کند، دو بلوک سالم بسازد.
\\
احتمال موفقیت حمله‌ی A مساوی
$(\frac{A's\ computational\ power}{Bitcoin\ network's\ computational\ power}) ^ 2 $
است. اگر توان محاسباتی A از دیگر قسمت‌های شبکه کمتر باشد، این کسر عددی کوچک‌تر از 
\lr{0.5}
است. اگر این کار به موقع با موفقیت انجام نشود، سه بلوک عقب می‌افتد و توان فرمول بالا تبدیل به سه می‌شود و احتمال موفقیتش کمتر از پیش می‌شود. 
\\
این مسئله مسئله‌ی قمارباز
\LTRfootnote{Gambler's Ruin}
نام دارد که نشان داده می‌شود در آن در طول زمان احتمال موفقت مهاجم به صورت نمایی کاهش پیدا می‌کند.
\par

از پرکاربرد‌ترین‌‌های این محصولات می‌توان به
\lr{LiteCoin}
و 
\lr{z-cash}
\cite{zerocash}
اشاره کرد. مزیت لایت‌کوین نسبت به بیت‌کوین در هزینه‌ی کمتر اضافه کردن بلوک و زمان تراکنش‌های کمتر است و زی‌کش امنیت بیشتری در زمینه‌ی حریم خصوصی و ناشناس ماندن ارائه می‌کند. 
\\ 
از نمونه‌های دیگر می‌توان به 
\lr{Ripple}
اشاره کرد، که برای تراکنش‌های بانک‌ها طراحی شده و همانطوری که بررسی کردیم از اثبات کار برای توافق استفاده نمی‌کند. 

\subsection{سازمان‌های توزیع‌شده‌ی خودکار}
دسته‌ی بعدی کاربرد‌های بلاک‌چین ایجاد سازمان‌های توزیع‌شده‌ی خودکار 
\LTRfootnote{Decentralized autonomous organization (DAO)}
است. این مفهوم بر اساس مفهوم قرارداد هوشمند
\LTRfootnote{Smart contract}
\cite{SmartContract}
 ساخته شده است. این سازمان‌ها برنامه‌هایی هستن که به طور خودکار و بی‌اعتماد در یستر بلاک‌چین ایجاد می‌شوند و می‌توانند کاربرد‌های بسیاری داشته باشند. اتریوم
 \LTRfootnote{Ethereum}
\cite{Ethereum}
که یک ارز دیجیتال است، یک بستر مناسب برای تولید قرارداد‌های هوشمند هم هست که در سال‌های اخیر کاربرد‌های بیشتری پیدا کرده‌اند. با این وجود یک دغدغه‌ای که همچنان در این بستر وجود دارد خطر اشتباه‌های برنامه‌نویسی در این سازمان‌هاست، از آن‌جا که تغییر کد اینگونه سازمان‌ها به دلیل خودکار بودن، همواره قابل تغییر نیست، اشتباهات امنیتی می‌تواند تاثیر مخرب عظیمی داشته باشند. atezi
\cite{surveyAtt}
به بررسی مشکلات امنیتی معمول قراردادهای در بستر اتریوم و تله‌ی معمول این زبان برنامه‌نویسی و روش‌های تصحیح آن‌ها پرداخته است. 
\\
یک‌ مسئله‌ی دیگر که ناشی از ناشناسی ذاتی این بستر‌هاست ایجاد شدن سازمان‌های مچرمانه در آن‌هاست. تحقیقات‌ بسیاری 
\cite{gyges} \cite{smart}
در این زمینه شده، و از مثال‌های قرارداد‌های مخرب ممکن می‌توان به افشای اطلاعات خصوصی و یا حتی دزدین کلید‌های رمز‌نگاری اشاره کرد. به دلیل عدم وجود نظارت مرکزی در این سیستم‌ها، راهی برای جلوگیری از اینگونه قرارداد‌ها وجود ندارد.
\subsection{شناسایی}
از کاربرد‌های دیگر بلا‌ک‌چین ساخت‌ روش‌های شناسایی
\LTRfootnote{Authentication}
است. ویژگی تغییر ناپذیری بلوک‌های قدیمی در یک بلاک‌چین، باعث می‌شود که ساختارداده‌ی ایده‌آلی برای شناسایی باشد. از این نمونه کاربرد‌ها می‌توان به \lr{namecoin} اشاره کرد. هدف این محصول کاهش نیاز به اعتماد در 
\lr{DNS} \LTRfootnote{Domain Name Service}
است. این محصول که روی بلاک‌چین بیت‌کوین ساخته شده است، در متن نوشته‌شده در تراکنش اطلاعات مربوط به نام دامنه‌ها را زخیره می‌کند. 
\par
از تخقیقات دیگر در این زمینه می‌توان به امنیت در داکر
\LTRfootnote{Docker}
\cite{docker}
اشاره کرد. در این تحقیق با استفاده‌ از بلاک‌چین یک بستر توزیع‌شده برای به اشتراک‌گذاری فایل‌های امضا شده ساخته شده است. در این سیستم‌ می‌توان از یک بلاک‌چین خصوصی و یا یه بلاک‌چین عمومی استفاده کرد. 


\section{رای‌گیری الکترونیک}
رای‌گیری الکترونیک را به طور کلی می‌توانیم به دو دسته‌ی رای‌گیری تماما الکترونیک و رای‌گیری به کمک ابزار‌های الکترونیکی تقسیم کرد. روش‌های دسته‌ی دوم مبتنی بر رای‌گیری سنتی هستند و از ابزاری‌های الکترونیکی صرفا برای کاهش هزینه و افزایش دسترسی پذیری استفاده می‌کنند. از این روش‌ها می‌توان به ابزارهای شمارش رای خودکار و یا دستگاه‌های ثبت رای‌الکترونیکی که خروجی آن‌ها یک برگه‌ی رای‌ کاغذی
\LTRfootnote{Direct-recording electronic voting systems or DRE}
 است اشاره کرد. در این تحقیق این ابزارها را بررسی نمی‌کنیم و منظور از رای‌گیری الکترونیک، دسته‌ی اول یا رای‌گیری تماما الکترونیک است.
 \par
سیستم‌های رای‌گیری الکترونیک را می‌توان به دو دسته‌ی کلی توزیع‌شده و متمرکز تقسیم کرد. سیستم‌های مرکزی نیازمند یک ارتباط امن از رای‌دهنده تا سرویس مرکزی هستند. همچنین نیازمند اعتماد کامل به همان یک سرویس برای درستی انتخابات است. در سیستم‌های توزیع‌شده تلاش می‌کنند تا این دو مسئله را کمرنگ‌تر کنند.

\subsection{رای‌گیری الکترونیک متمرکز}
در این سیستم‌ها یک سامانه‌ی مرکزی وجود دارد که تمامی آرا در آن زخیره می‌شند. در این سیستم‌ها حوزه‌های رای‌گیری می‌توانند وجود داشته باشند اما حوزه‌ها صرفا وظیفه‌ی احراز هویت و ارائه‌ی درگاه امن برای ثبت رای در سامانه‌ی مرکزی را دارند. حریم خصوصی کاربران در این سیستم‌ها مبتی بر استفاده از کانال‌های ارتباطی ناشناس 
\LTRfootnote{Anonymous communication channel}
بین حوزه‌های رای‌گیری و سامانه‌ی مرکزی است.
\par
 اولین تحقیق در رابطه با استفاده‌ از کانال‌های ارتباطی ناشناس برای رای‌گیری در سال ۱۹۸۵ توسط 
\lr{Chaum}
\cite{Chaum}
بود که در آن برای ساخت‌ کانال‌های ارتباطی ناشناس از امضای کورکورانه 
\LTRfootnote{Blind signature}
\cite{blindsig}
برای ایجاد یک ارز دیجیتل استفاده می‌شد. در امضای کورکورانه، برای حفظ حریم خصوصی فردی که باید اطلاعاتی را تایید کند، رمزشده‌ی اطلاعات را امضا می‌کند، به این صورت از اطلاعات پیام باخبر نمی‌شود. اولین تلاش برای ایجاد یک پروتکل رای‌گیری الکترونیک با امضای کورکورانه در سال ۱۹۹۲ 
\cite{foo92}
بود و در ادامه در سال ۱۹۹۷
\cite{improveblind}
نسخه‌ی کامل‌تری از آن ارائه شد. این روش‌ها مبتنی بر وجود یک شمارنده و یک حوزه هستند، حوزه احراز هویت را انجام می‌دهد و برگه‌ رای‌های ناشناس صادر می‌کند و سپس از طریق یک کانال ارتباطی ناشناس رای‌دهنده رای را به شمارنده می‌دهد. از مشکلات این روش می‌توان به نیاز به اعتماد به حوزه اشاره کرد. حوزه می‌تواند که با ارائه رای‌های اشتباه بدون توانایی پیگیری، رای‌گیری را خراب کند، برای حل این مشکل تحقیقاتی
\cite{multiteller}
 در راستای استفاده از چند حوزه انجام شده است. مشکل بزرگ دیگر این روش‌ها
\cite{anonchan}
  سختی ناشناس نگه‌داشتن کانال‌های ارتباطی ناشناس است.

\subsection{رای‌گیری الکترونیک توزیع‌شده}
رای‌گیری الکترونیک توزیع‌شده را به دو دسته‌ی رای‌گیری‌های بدون بلاک‌چین و با بلاک‌چین عمومی و با بلاک‌چین خصوصی تقسیم می‌کنیم. با توجه به این که در رای‌گیری احرازهویت یک مسئله‌ی مهم است همه‌ي این سیستم‌ها از بلاک‌چین‌های بسته استفاده می‌کنند.
\subsubsection{رای‌گیری بدون بلاک‌چین} 
بعضی سیستم‌های طراحی شده برای رای‌گیری الکترونیک
\cite{secret1}
\cite{secret2}
\cite{secret3}
 از روش‌های تقسیم راز
\LTRfootnote{Secret sharing}
 استفاده می‌کنند. در این روش‌ها فرایند ثبت رای باید به تایید تعدادی از حوزه‌ها برسد که باعث کاهش نیاز به اعتماد می‌شود. در این روش‌ها می‌توان اثبات کرد که برای ردیابی یک رمز حداقل $k$ حوزه باید تبانی کنند. 
 \par
 روش دیگری که برای رای‌گیری توزیع‌شده استفاده شده است، استفاده از بردار‌ بررسی
 \LTRfootnote{Check vector}
 \cite{checkvector}
 است. در این روش‌ها بررسی درستی رای‌ها کاملا توزیع‌شده‌ است اما نیاز به ارتباط دو به دوی تمامی رای‌دهنده‌ها دارد که در یک انتخابات واقعی شدنی نیست. ترکیبی از این روش و تقسیم راز باعث ایجاد پروتکل‌هایی
 \cite{MPO1} \cite{evotinwocrypto}
  شد که با سطح‌بندی حوزه‌ها و تقسیم رای‌ها و مخلوط کردن آن‌ها از حریم خصوصی حمایت می‌کنند. اما این روش‌ها به حوزه‌ها و رای‌دهندگان توانایی بررسی درستی برگه رای‌ها را نمی‌دهد و امکان ایجاد رای‌های اشتباه و جلوگیری از رای‌دادن یک فرد خاص را ایجاد می‌کنند. 


\subsubsection{رای‌گیری با بلاک‌چین عمومی}
با فراگیر شدن تکنولوژی بلاک‌چین
\cite{rosgood}
، محصولاتی در زمینه‌ی رای‌گیری الکترونیک به کمک این تکنولوژی ساخته شدند. تعدادی از این سیستم‌های رای‌گیری در قالب قرارداد‌های هوشمند ساخته‌ شنده‌اند که از آن‌ها می‌توان به وتریم 
\LTRfootnote{Votereum}
\cite{votereum}
و یا کار 
\lr{E.Yavuz}
\cite{yavuz}
در بستر اتریوم اشاره کرد. مزیت اینجور رای‌گیری‌ها هزینه‌ی اولیه کم استفاده از آن‌هاست، اما همچنان ریسک اشتباه برنامه‌نویسی در این سبک کارها بسیار بالاست. همچنین هزینه اجرای قراردادهای هوشمند به تعداد بالا برای یک رای‌گیری هزینه‌ی بالایی خواهد داشت که در طول زمان باعث افزایش هزینه‌ی رای‌گیری خواهد شد. مسئله‌ی دیگر در بستر اتریوم هم وابستگی سیستم رای‌گیری، به پهنای باند نود‌های اتریوم و میزان بار روی شبکه‌ی آن است. این موضوع می‌تواند باعث کند شدن یا حتی در مواردی حذف شدن تعدادی از آرا شود.


\subsubsection{ٰرای‌گیری با بلاک‌چین خصوصی}
از سیستم‌های رای‌گیری با بلاک‌چین خصوصی می‌توان به 
\lr{VoteBook}
\cite{votebook}
توسط شرکت 
\lr{Kaspersky}
که یک شرکت پیشرو در زمینه‌ی امنیت است اشاره کرد. فلسفه‌ی ساخت این سیستم به صورتی است که تلاش می‌کند برای کاربرانی که از سیستم‌هایی رای‌گیری فعلی استفاده می‌کنند کمترین تغییر در رفتار نیاز باشد. 
\\
از مثال‌های دیگر سیستم‌های رای‌گیری مبتنی بر بلاک‌چین می‌توان به استارت‌آپ 
\lr{Follow My Vote}
اشاره کرد. نجوه‌ی کار این سیستم با سیستم 
\lr{VoteBook}
تفاوت اساسی دارد و برای رای‌دادن احتیاج دارد که نرم‌‌افزاری برای رای‌دادن به روی کامپیتور و یا تلفن‌همراه کاربران نصب شود. اینگونه طراحی سیستم،‌ خطرات امنیتی در قالب بدافزار ایجاد می‌کند. همچنین با نبود یک حوزه‌ی رای‌گیری امن راهی برای تامین امنیت رای‌دهندگان و اطمینان حاصل کردن از این که کسی مجبور به رای‌ دادن نشده، نیست.
\\
یکی از موفق‌ترین سیستم‌های رای‌گیری مبتنی بر بلاک‌چین موجود در حال حاضر 
\lr{VoteWatcher}
ساخته شده توسط یک شاخه از شرکت 
\lr{blockchain Technologies Corporation}
است که یک شرکت بزرگ برای ارائه‌ی سرویس‌های مبتنی بر بلاک‌چین است. طبق وب‌سایت این محصول تاکنون بیش از صدهزار رای در بیشتر از ۲۰ رای‌گیری مختلف توسط این سیستم‌ شمارش شده‌است. 
\\
مدل اسفاده‌ی 
\lr{VoteWatcher}
به سیستم‌ 
\lr{VoteBook}
بسیار شبیه است و تفاوت رفتاری زیادی با مدل‌های رای‌گیری الکترونیکی فعلی برای کاربران ندارد. در این محصول طبق نیاز رای‌گیری می‌توان از یک بلاک‌چین عمومی یا خصوصی استفاده کرد.
\\
از موارد دیگر می‌توان به پیاده‌سازی‌های به کمک قرارداد‌های هوشمند ولی با استفاده از بلاک‌چین خصوصی 
\cite{privblock}
که توانایی ردگیری بالاتری از پیاده‌سازی‌های دیگر ارائه می‌کنند، اما به دلیل کندی نسبی، نیاز به تقسیم رای‌گیری به چند رای‌گیری کوچک‌تر دارند.

\section{اثبات‌های بی‌دانش}
اثبات‌های بی‌دانش اولین بار در سال ۱۹۸۵ 
\cite{GHY}
به عنوان روشی ساخت یک روش رمزنگاری متقارن با کلید عمومی استفاده شد. با پیشرفت تکنولوژی اثبات‌های بی‌دانش،‌ روش‌های جامع اثبات بی‌دانش مانند
\lr{ZK-SNARK} 
\cite{zksnark}
و \lr{ZK-STARK} 
\cite{zkstark}
بوجود آمدند. این روش‌ها توانایی اثبات هر محاسباتی را به صورت بی‌دانش دارند و این موضوع باعث استفاده‌ی آن‌ها در کاربردهای بیشتری شد.
\subsection{کاربرد‌ها}
با فراگیری ارز‌های دیجیتال، مسئله‌ی حریم خصوصی در آن‌ها پررنگ‌تر شد. در ابتدا یکی از بزرگ‌ترین کاربردهای بیت‌کوین پرداخت‌های مجرمانه بود که ناشناسی نسبی در این بستر باعث می‌شد برای این سبک‌ پرداخت‌ها ایده‌آل باشند. اما به دلیل عمومی بودن بلاک‌چین و تمامی تراکنش‌ها در آن دنبال کردن رد پرداخت بسیار ساده است.
\par
 برای جلوگیری از این ردگیری در کاربردهای مجرمانه از یک شخص مورد اعتماد برای «مخلوط کردن» سکه‌های افراد استفاده می‌شود. در این روش چندین نفر به یک نفر پرداخت می‌کنند و آن فرد به کلید‌های عمومی که از قبل تعیین شده با سکه‌های جدید پرداخت می‌کند اما در این روش همگی به شخص مخلوط کننده اعتماد می‌کنند که به اندازه پرداخت کند و رد واقعی سکه‌ها را جایی ثبت نکند. این روش برای کاربردهای مجرمانه تا حد بسیار خوبی پاسخگو است اما برای افراد عادی که صرفا دغدغه‌ی حریم خصوصی خود را دارند خطرها و هزینه‌ي این روش معقول نیست، به همین دلیل کارهای مختلفی در زمینه‌ی پرداخت ناشناس انجام شده است. 
 
\subsubsection{پرداخت ناشناس}
از این تحقیقات می‌توان به بستر 
\lr{HAWK}
\cite{hawk}
اشاره کرد. در این تحقیق به کمک یک تعریف کلی از بلاک‌چین به عنوان سیستمی که همواره در دسترس است و هیچ اطلاعات اشتباه نمی‌پذیرد اما حریم خصوصی را حفظ نمی‌کند یک بستر قرارداد هوشمند ساخته شده است که در آن به ازای کد قرارداد هوشمند، یک کد برای حفظ حریم خصوصی به کمک اثبات‌های بی‌دانش ساخته می‌شود. روش کار این سیستم مبتنی بر ایجاد آدرس‌های مقصد یکتا به ازای هر تراکنش است. 
\\
مونرو 
\LTRfootnote{Monero}
که یک ارز دیجیتال است که بر اساس الگوریتم 
\lr{Cryptonote}
\cite{monero}
کار می‌کند، به مانند 
\lr{HAWK}
با یکتا سازی آدرس‌های مقصد و امضای حلقه‌ای 
\LTRfootnote{ًRing Signature}
کار می‌کند. در ادامه این ارز دیجیتال با همین روش مدلی 
\cite{monero2}
برای مخفی کردن پرداخت‌کننده‌ی سکه نیز ارائه کرد.
\par
از کارهای دیگر در این زمینه‌ می‌توان به 
\lr{zerocoin}
\cite{zerocoin}
که روش پرداخت ناشناس بر بستر بیت‌کوین به کمک 
\lr{ZK-SNARK}
ارائه کرد اشاره کرد. روش استفاده شده در آن با بهبود در ارز دیجیتال 
\lr{z-cash}
\cite{zerocash}
استفاده شد. این ارز دیجیتال دو مدل سکه‌ی قابل ردگیری و غیرقابل ردگیری دارد و هر کسی می‌توان طی یک تراکنش سکه‌های خود را به سکه‌های ناشناس تبدیل کند.

. 
\subsection{فاز آماده‌سازی}
با توجه به این که 
\lr{ZK-SNARK}
‌ها، به طور خاص خاص پروتکل پینوکیو
\LTRfootnote{Pinocchio}
فراگیرترین روش برای ایجاد اثبات‌های بی‌دانش است. تحقیقات زیاد در مورد فاز آماده‌سازی و ایجاد پارامترهای عمومی این مدل اثبات شده است. همانطور که قبلا اشاره کردیم ورودی‌های این فاز اگر بعد از این فاز پاک نشوند می‌توانند برای ایجاد اثبات‌های تقلبی استفاده شوند.
\par
از این تحقیق‌ها می‌توان به روش‌هایی
\cite{znsetup} \cite{multipartyparams}
 که تلاش در کاهش نیاز به اعتماد در این فاز می‌کنند اشاره کرد. این روش‌ها باعث می‌شوند که برای لو رفت اطلاعات خطرناک احتیاج به تبانی تمامی اعضای موجود در فاز آماده‌سازی باشد.
 \par
 از دیگر کارهای در این زمینه می‌توان به تلاش‌هایی برای حذف فاز آماده‌سازی به طور کلی اشاره کرد. این روش‌ با تغییر اساسی در پروتکل و استفاده از چندجمله‌ای‌ها 
 \cite{nosetup}
 مرحله‌ي آماده‌سازی را حذف می‌کند

\cchapter{روش پیشنهادی}
در این بخش به بررسی روش پیشنهادی این تحقیق می‌پردازیم، در ابتدا شرایطی که در آن مسئله را حل کنیم بررسی می‌کنیم و شرط‌های لازم برای سیستم‌ رای‌گیری خود را بررسی می‌کنیم، در ادامه به بررسی کلی روش رای‌گیری عناصر حاضر در آن می‌پردازیم و در نهایت الگوریتم‌ها و پروتکل دقیق را بررسی می‌کنیم.

\section{تعریف عناصر}
در این بخش عناصر حاضر در سیستم رای‌گیری و انتظارات خود از آن‌ها را تعریف می‌کنیم:
\begin{itemize}
	\item
	\textbf{ناظر انتخابات}:
	این سازمان مسئول بررسی درستی انتخابات و احراز هویت شرکت‌کنندگان در انتخابات است. به این سازمان اعتماد می‌شود تا کار احراز هویت را به درستی انجام دهد. همچنین این سازمان بررسی‌کننده‌ی نهایی درست بودن انتخابات است و باید بتواند از درستی انتخابات اطمینان حاصل کند.
	\item
	\textbf{رای‌دهنده}:
	فردی که حق رای به یک کاندیدا را دارد، این فرد می‌تواند از رایش استفاده بکند یا نکند، می‌تواند تلاش کند که چند بار رای‌دهد. باید بتواند از درستی انتخابات اطمینان حاصل کند. ممکن است توسط یک رقیب بدخواه برای رای‌دادن تحت فشار قرار بگیرد.
	\item
	\textbf{حوزه‌ی انتخابات}:
	محلی که در آن رای داده می‌شود، باید بتواند امنیت فیزیکی افراد را تامین کند. ممکن است برای خراب کردن انتخابات یا نقض حریم خصوصی کاربران تلاش کند. 
\end{itemize}
\section{شرایط مسئله}
شروط لازم برای سیستم‌ رای‌گیری ارائه شده عبارتند از:  
\begin{enumerate}
	\item 
	هر فرد واجد شرایط دقیقا یک بار بتواند رای دهد.
	\item 
	هیچ کسی نتواند به جای فرد دیگری رای دهد.
	\item 
	هیچ فردی مجبور به رای دادن نشود.
	\item 
	هیچ فردی مجبور به رای دادن به کاندیدای خاصی نشود.
	\item 
	در صورت نقض حریم خصوصی و یا شمارده نشدن بعضی رای‌ها ناظر انتخابات بتواند حوزه‌ي متخلف را شناسایی کند. حوزه‌ها به دلیل در اختیار داشتن سامانه‌های کامپیوتری رای‌گیری همواره می‌توانند با روش‌های 
	\lr{phishing}
	و یا استفاده از بد‌افزار‌ها حریم خصوصی کاربر را زیر سوال ببرند یا رای او را ثبت نکنند. به همین دلیل قابل پیگیری بودن تخلفات حوزه‌ها یکی از مهم‌ترین شرایط یک انتخابات درست است.
	\item 
	هر رای‌دهنده بتواند به کمک ابزارهای رمزنگاری اطمینان حاصل کند که رای او شمرده شده است. این شرط به این معنی است که هر کاربری که دانش کافی داشته باشد باید بتواند از درستی انتخابات - بدون نیاز به اعتماد به حوزه یا حتی ناظر انتخابات - اطمینان حاصل کند. 
	\item
	رای‌دهنده نیازی به دانش یا توانایی خاصی برای رای‌دادن نداشته باشد. این نیازمندی برای دسترس‌پذیر نگه‌داشتن انتخابات لازم است.
	\item
	سیستم رای‌گیری نسبت به روش‌های فعلی رای‌گیری از دید کاربر تفاوت چندانی نداشته باشد. هر تغییر اساسی از نگاه رای‌هنده باعث سختی نسبی انتخابات خواهد شد و هزینه‌ی اولیه استفاده از این سیستم انتخاباتی را به شدت افزایش خواهد داد.
	\item 
	بتوان نتایج انتخابات را در بازه‌های زمانی معین دید. هر سیستم انتخاباتی که نتایج لحظه‌ای نشان دهد همواره در خطر حمله‌های مبتنی بر زمان در رابطه با حریم خصوصی رای‌دهندگان خواهد بود، به همین منظور نتایج انتخابات را می‌توان در بازه‌های زمانی که حریم خصوصی را به خطر نیندازد نشان داد.
	\item 
	بتوان از شمارده شدن تمامی آرا بعد از انتخابات اطمینان حاصل کرد. به دلیل الزام مخفی نگه‌داشتن زمان حدودی ارسال هر رای، نتایج نهایی انتخابات تنها بعد از اتمام رای‌گیری قابل اتکاست.
\end{enumerate}

\section{فرضیات مسئله}
در این تحقیق هدف ارائه‌ی یک پروتکل رای‌گیری امن است و در این روش به جزییات پیاده‌سازی و مسائل 
\par
مسئله‌ی شناسایی یک مسئله‌ی مهم در هر انتخابات است، با توجه به این که افراد واجد شرایط بسته به هر انتخابات تغییر می‌کنند در این مسئله فرض می‌کنیم که هر رای‌دهنده یک جفت کلید خصوصی و عمومی دارد که قبل از فرایند انتخابات توسط ناظر انتخابات تایید شده است. 
\par
وظیفه‌ی حفظ امنیت کلید عمومی و خصوصی هر کاربر به عهده‌ی خود کابر خواهد بود چرا نشانگر هویت کاربر در سیستم‌ کلید عمومی او خواهد بود. هر چند که برای رای دادن در حوزه اطلاعات شناسایی کابر با کلید عمومی او تطابق داده خواهد شد.
\par
هر رای‌دهنده برای ثبت رای نیاز به یک دستگاه هوشمند دارد، از آن‌جایی که این دستگاه صرفا برای امضای کورکورانه استفاده می‌شود برای دسترس‌پذیری بالاتر می‌توان این دستگاه را در حوزه ارائه کرد و رای‌دهندگان تنها کلید خصوصی خود را در آن وارد کنند. بدیهیست که انجام این کار نیاز اعتماد به حوزه را بالاتر می‌برد چرا که رای‌دهنده راهی برای اطمینان حاصل کردن از این که دستگاه برنامه‌ی درستی را اجرا می‌کند ندارد.

\section{مثال شهودی}
برای بدست آوردن دید کلی در راه‌حل ابتدا یک مثال شهودی از یک مدل رای‌گیری متمرکز را بررسی می‌کنیم،‌ سپس در ادامه از این روش برای ایجاد سیستم توزیع‌شده و الکترونیکی خود استفاده می‌کنیم.
\par
یک رای‌گیری را فرض می‌کنیم که در آن به ازای هر رای‌دهنده یک کاغذ نام رای‌دهنده و یک برگه‌ی رای وجود دارد. همچنین یک صندوق به ازای هر کاندیدا وجود دارد و همه‌ی این اطلاعات در معرض دید عموم هستند. 
\par
آلیس برای رای‌دادن یکی از کاندیداها را انتخاب می‌کند، مسئول حوزه یک کاغذ رمز شده که در آن ک شماره‌ی تصادفی $r$ و کاندیدای موردنظر خود، باب، نوشته شده را به آلیس می‌دهد تا امضا کند، آلیس پس از اطمینان حاصل کردن از درستی ثبت کاندیدا (ولی بدون فهمیدن $r$) آن را امضا می‌کند. ثبث مسئول حوزه این عبارت رمز شده و برگه‌ی رای مربوط به آلیس را به تخته می‌چسباند. این فرایند را ثبت رای‌ می‌نامیم.
\\
در ادامه پس از مدتی مسئول حوزه تخته مراجعه‌ی می‌کند و شاهدی بر تخته ثبت می‌کند که ثابت می‌کند او یک کلیدرمزی می‌داند که یکی از کاغذ‌های روی تخته را باز می‌کند که نتیجه‌ی آن $r$ و باب است. سپس یکی از رای‌های روی تخته را برمی‌دارد و به صندوق باب می‌اندازد. این فرایند را شمارش رای‌ می‌نامیم.
\par
 شاهد آلیس در تخته ثبت شده و دیگر نمی‌توان اثباتی ارائه کرد که رای آلیس را دو بار بشمارد، چرا که عدد $r$ آن تکراری خواهد بود.
\\
از طرفی از آن‌جا که مسئول حوزه نشان نداده که کدام عبارت رمز شده به باب رای‌داده، در نتیجه حریم خصوصی آلیس محفوظ می‌ماند.
\\ 
چون حوزه‌ی انتخابات محل امنی برای رای‌ دادن است راهی برای مجبور کردن آلیس به رای دادن به کاندیدای خاصی نخواهد بود و با اضافه کردن صندوق رای ممتنع می‌توانیم اطمینان حاصل کنیم که کسی آلیس را مجبور به رای‌دادن نیز نکرده است. 

\section{فرایند رای‌گیری از نگاه کاربر}
یکی از مهم‌ترین قسمت‌های طراحی یک سیستم رای‌گیری تاثیر آن بر رای‌دهنده است چرا که در انتخابات‌های بزرگ هزینه‌ی تغییر رفتار رای‌دهندگان یا سخت‌تر شدن فرایند رای‌گیری به هر نحوی می‌تواند باعث کاهش شرکت رای‌دهندگان و افزایش هزینه‌ی تغییر رای‌گیری شود.
\par
فرایند رای‌گیری را به دو بخش قبل از رای‌گیری و در حوزه‌ی رای‌گیری تقسیم می‌کنیم. 
\subsection{قبل از رای‌گیری}
قبل از رای‌گیری هر فرد واجد شرایط باید از یک روش امن از ناظر انتخابات یک جفت کلید عمومی و خصوصی دریافت کند و یا کلید عمومی خود را در سامانه‌ی مربوط ثبت کند. این کلید می‌تواند در قالب یک فایل بر روی یک دستگاه هوشمند - مثلا تلفن همراه یا حتی یک کارت هوشمند - باشد. این مرحله  می‌تواند در هر انتخابات تکرار شود یا یک فرایند ابتدایی باشد و برای انتخابات‌های بعدی نیز استفاده شود. 
\subsection{در حوزه‌ی رای‌گیری}
در حوزه‌ی رای‌گیری رای‌دهنده پس از ورود کارت شناسایی و کلید عمومی خود را ارائه می‌کند، در صورت تایید اطلاعات کاربر، کاربر با دستگاه هوشمند خود به سیستم‌ حوزه متصل می‌شود و رای‌ خود را از بین‌ کاندیدا‌های ممکن و یا ممتنع وارد می‌کند و پیام تایید را دریافت می‌کند. 
\section{فرایند رای‌گیری از دید حوزه‌}
در این بخش فرایند رای‌گیری را از نگاه حوزه‌ بررسی می‌کنیم، در این بخش صرفا منطق پروتکل را بررسی می‌کنیم و جزییات بلاک‌چین و عملیات توزیع شده نمی‌پردازیم. 
\\
برای ثبت رای یک‌ نفر در ابتدا آن فرد با کارت شناسایی احراز هویت می‌شود و از طریق ارتباط با ناظر انتخابات درستی کلید عمومی آن فرد بررسی می‌شود. در مرحله‌ی بعدی با ارائه‌ی کلید خصوصی کاربر یک تراکنش ثبت با نتیجه‌ی مورد نظر ایجاد می‌کند و تراکنش ثبت توسط دستگاه هوشمند کاربر کوکورانه امضا می‌شود. در این مرحله تراکنش شمارش نیز ایجاد می‌شود و با تاخیر زمانی در بلاک‌چین ذخیره می‌شود.

\subsection{تراکنش‌ها}
در این بخش تراکنش‌ها ثبت و شمارش را تعریف می‌کنیم.
\subsubsection{تراکنش ثبت}
در تراکنش ثبت یک رای از یک کلید عمومی به دسته‌ی رای‌های منتظر شمارش منتقل می‌شود. هر تراکنش ثبت شامل یک رای و یک رشته 
\LTRfootnote{string}
رمز شده است که حاوی یک عدد تصادفی $s$ و حساب مقصد $d$ است که با کلید تصادفی $k$ رمزشده است. این عبارت رمز‌شده رای $CM$ می‌نامیم. سپس $CM$ (نه خود $s$) در بلاک‌چین به همراه رای ثبت می‌شود.
\\
\begin{equation}
CM = enc_{k} (r, d)
\label{eq:enc}
\end{equation}
\subsubsection{تراکنش شمارش}
مدل دیگر تراکنش ممکن تراکنش شمارش است که در آن شاهدی برای شمارش رای ارائه می‌شود. برای این تراکنش رای‌دهنده اثبات بی‌دانشی برای دو موضوع ارائه می‌کند: یک $C$ می‌شناسد به طوری که  $C \in C_1, C_2, ... ,C_n$ و یک رشته‌ای $r$ می‌داند که $C$ را به $s$ و $d$ باز می‌کند. در نتیجه‌ی این اثبات یکی از رای‌های ثبت‌شده به $d$ منتقل می‌شود.
\par
لازم به ذکر است که از آنجایی که در تراکنش شمارش $C$ و $r$ نشان داده نشده‌اند، راهی برای فهمیدن این که رای متعلق به چه کسی است وجود ندارد.

\subsection{فرایند ثبت رای کاربر}
در این بخش پروتکل ثبت رای حوزه را به طور دقیق بررسی می‌کنیم، در این بخش منظور از کاربر دستگاه هوشمند اوست. 

\begin{enumerate}
	\item 
	کاربر گزینه‌ی مورد نظر خود را انتخاب می‌کند، حوزه به تعداد $n$ تا $CM$ می‌سازد که رای کاربر به کاندیدای مورد نظر را نشان می‌دهند، هر کدام را با یک کلید تصادفی رمز می‌کند و برای تایید به کاربر می‌دهد. 
	\item 
	یکی از از عبارات رمزشده به طور تصادفی توسط کاربر $CM_c$ انتخاب می‌شود و به حوزه اعلام می‌شود.
	\item 
	حوزه کلید مربوط به تمامی $CM$های دیگر را به کاربر ارائه می‌کند.
	\item 
	کاربر همه‌ی $CM$ها را باز می‌کند و چک می‌کند که در همه‌ی آن‌ها رای به نام کاندیدای مورد نظر او ثبت شده باشند. با این روش کاربر با احتمال $\frac{n-1}{n}$ از درستی رای در $CM_c$ مطمئن می‌شود. سپس کاربر $CM_c$ را با کلید خصوصی خود امضا می‌کند و به حوزه می‌دهد. در نتیجه‌ی این کار کاربر راهی برای فهمیدن عدد تصادفی در $CM_c$، که آن را $s$ می‌نامیم، ندارد.
	\item
	حوزه $CM_c$ را به همراه رای موجود در حساب کاربر به عنوان یک تراکنش ثبت در بلاک‌چین ذخیره می‌کند. در صورتی که رای کاربر قبلا ثبت شده باشد در این مرحله خطا رخ می‌دهد و رای ثبت نمی‌شود. 
	\item
	حوزه یک شاهد برای شمارش رای کاربر می‌سازد و هر دوی این تراکنش‌ها در بلوک بعدی بلاک‌چین ذخیره می‌شوند.
\end{enumerate}
شکل \ref{fig:seqdiag.png} این توالی فرایند را نشان می‌دهد.
\begin{figure}[t!]
	\centering
	\includegraphics[width=1\linewidth]{seqdiag.png}
	\caption {فرایند ثبت رای در حوزه}
	\label{fig:seqdiag.png}
\end{figure}

\section{شمای کلی}
به طور کلی سیستم از تعدادی حوزه‌ تشکیل می‌شود که روی یک بلاک‌چین توافق می‌کنند. همچین هر حوزه ممکن است بلوک‌ آماده شده و منتظر گرفتن تایید از بقیه‌ی حوزه‌ها داشته باشد، یا این که بلوکی از حوزه‌ی دیگری گرفته باشد که باید بررسی و امضا کند، شکل \ref{fig:bigpic} شمای کلی درشت‌دانه‌ی سیستم را نشان می‌دهد.
\\
بلوک ابتدایی این بلاک‌چین به ازای هر فرد واجد شرایط یک کلید عمومی و یک رای‌دارد. همچنین یک آدرس خروجی به ازای هر کاندیدا وجود دارد که تعداد رای‌هایی که به آن آدرس فرستاده شده باشند رای‌های آن‌ کاندیداست. 
 
\begin{figure}[th]
	\centering
	\includegraphics[width=1\linewidth]{blockchain.PNG}
	\caption {شمای منطقی سیستم}
	\label{fig:bigpic}
\end{figure}

\subsection{اضافه شدن بلوک}
می‌دانیم که در هر بلوک ثبت‌شده در بلاک‌چین تعدادی از دو مدل تراکنش‌های ثبت و شمارش داریم، همچنین هش بلوک قبلی را نیز برای اطمینان از تغییر نکردن بلوک‌های قبلی نگه‌می‌داریم. مسئله‌ای که در اینجا باقی می‌ماند نحوه‌ی توافق روی یک بلاک‌چین است. در این تحقیق از یک بلاک‌چین عمومی و بسته استفاده می‌کنیم.
\\
هر حوزه یک بافر برای نگه‌داری تراکنش‌های مربوط به آرا دارد که قبل از ثبت در بلاک‌چین که آن را تبدیل به یک بلوک می‌کند. برای اضافه شدن هر تراکنش روی بلاک‌چین باید حداقل نصف به علاوه‌ی یکی از حوزه‌ها روی آن توافق کنند. هر حوزه برای توافق بررسی می‌کند که که تراکش‌های مربوط به رای دادن و شاهد‌های ثبت شده در بلوک جدید درست باشند و هش بلوک قبلی نیز در بلوک صحیح باشد. هر حوزه‌ی بلاک‌چین را با امضای دیجیتال خود تایید می‌کند. 

\subsection{مقادیر اولیه  برای \lr{ZK-SNARK}}
همانطور که قبلا اشاره کردیم برای استفاده از روش \lr{ZK-SNARK} برای ایجاد‌ شاهد‌های بی‌دانش احتیاج به توافق روی نقاط اولیه‌ای روی یک \lr{elliptic curve} داریم. برای انجام این کار از روش ارائه شده در تحقیق 
\cite{multipartyparams}
استفاده می‌کنیم. در این روش برای ایجاد نقاط اولیه از تقسیم مسئله‌ بین افراد توافق‌کننده استفاده می‌شود، به صورتی که حاصل ضرب اطلاعات همه‌ی افراد نقاط اولیه را تشکیل می‌دهند و برای لو رفتن آن باید تمامی حوزه‌ها تبانی کنند. در این روش خود برای ایجاد پارامترها از یک حالت خاص اثبات‌های بی‌دانش استفاده می‌شود. 
\subsection{توافق}
 در بلاک‌چین‌های عمومی معمولا یک مسئله‌ در توافق حالت‌هاییست که بلاک‌چین دو شاخه می‌شود، یعنی دو مدل از بلاک‌چین وجود داشته باشد که هر کدام را قسمتی از شبکه به عنوان بلاک‌چین درست بشناسند. در بسیاری از ارزهای دیجیتال طولانی‌ترین بلاک‌چین از نظر تعداد بلوک‌ها همواره به عنوان نسخه‌ی درست شناخته می‌شود اما در یک سیستم رای‌گیری این کار باعث کم شدن رای‌‌ می‌شود و این ریسک قابل قبولی نیست. 
 
\subsubsection{قضیه‌ی \lr{CAP}}
این قضیه‌ی معروف 
\cite{CAP}
اثبات می‌کند که در یک دیتابیس توزیع‌شده - مانند یک بلاک‌چین - در هر بازه‌ای حداکثر می‌توان دو شرط از سه شرط همخوانی 
\LTRfootnote{Consistency}
، دردسترس بودن 
\LTRfootnote{Availability}
و تحمل قسمت‌شدن
\LTRfootnote{Partition tolerance}
را می‌توانند داشته باشند.با توجه به این که هیچ زمانی نمی‌توانیم روی درستی شبکه حساب کنیم سیستم‌ ما در حال \lr{CP} عمل می‌کند. معمولا در سیستم‌ها مبتنی بر بلاک‌چین از روش‌های  که گارانتی می‌کنند که همه‌ی نودها در نهایت به همخوانی می‌رسند
\LTRfootnote{Eventual consistency}.
اما در یک سیستمی که برای رای‌گیری استفاده می‌شود این مسئله می‌تواند خطر گم شدن تعدادی از آرا ایجاد کند و این خطر معقولی برای یک‌ سیستم‌ رای‌گیری الکترونیکی نیست.
\par
در بلاک‌چین‌های عمومی معمولا از روش‌های اثبات کار و اثبات‌ سهم استفاده می‌شود که دسترس پذیری و تحمل قسمت‌شدن را به خوبی ارائه می‌کنند اما ممکن است شاخه‌های
\LTRfootnote{fork}
لحظه‌ای پیش بیاید و چند نسخه از بلاک‌چین درست وجود داشته باشد، معمولا در این روش‌ها طولانی‌ترین بلاک‌چین نسخه‌ی درست در نظر گرفته می‌شود و بلاک‌چین‌های کوتاه‌تر حذف می‌شوند. از آن‌جایی که این کار در سیستم ما باعث از بین رفتن رای‌ می‌شود باید در روش دیگری استفاده کنیم.
\par
در این تحقیق سه روش برای تفاوق را بررسی می‌کنیم. روش اول \lr{Aura}
\cite{Aura}
 نام دارد. در این روش نود یک نود رهبر بلوک‌های جدید ارائه می‌کند و در طور زمان در دوره‌های مشخصی رهبر تغییر می‌کند. برای انتخاب زمان تغییر از ساعت \lr{unix} استفاده می‌شود که می‌تواند در اثر همگام
\lr{sync}
 نبودن ساعت نود‌های حاضر در شبکه در یک لحظه دو رهبر وجود داشته باشد. این باعث از بین رفتن همخوانی در سیستم می‌شود ولی سیستم همواره در دسترس خواهد بود. 
\par
روش دیگر \lr{Clique} 
\cite{Clique}
نام دارد. این روش شبیه \lr{Aura} عمل می‌کند با این تفاوت که برای همگامی نودها به جای استفاده از ساعت، از تعداد بلوک ثبت شده در بلاک‌چین استفاده می‌شود، همچنین در این روش، نود‌هایی غیر از نود رهبر نیز می‌توانند بلوک جدید پیشنهاد کنند. این کار می‌تواند باعث ایجاد شاخه‌ در بلاک‌چین شود اما در طول زمان با تغییر رهبر یکی از دو شاخه حذف خواهد شد. این روش نیز در نهایت به همخوانی می‌رسد اما ریسک حذف شدن رای را سیستم وارد می‌کند.
\par

راه‌حلی در در پروتکل ارائه شده در این تحقیق برای این موضوع استفاده کردیم
\lr{PBFT}
\LTRfootnote{Practical Byzantine fault tolerance}
\cite{PBFT}
نام دارد. این روش هزینه‌ی محاسباتی بسیار کمتری از روش‌های مبتنی بر اثبات کار دارد و از نظر مقیاس پذیری
\cite{PBFperf}
نیز بسیار بهتر عمل می‌کند.

\begin{table}[th!]
	\begin{center}
		%		\def\arraystretch{2}
		\caption{روش توافق}
		\begin{tabular}{|c|c|c|c|}
			\hline
			& هم‌خوانی & دردسترس بودن & تحمل تقسیم شدن \\
			\hline
		 اثبات کار & همخوانی‌ در نهایت & دارد(اما ممکن است بلوک حذف شود) & دارد \\
			\hline
		 اثبات سهم & همخوانی‌ در نهایت & دارد(اما ممکن است بلوک حذف شود) & دارد \\
\hline
		 Aura & گارانتی نمی‌کند & دارد & دارد \\
\hline
		 Clique & همخوانی‌ در نهایت & دارد(اما ممکن است بلوک حذف شود) & دارد \\
\hline
PBFT & دارد & در صورت تقسیم شدن ندارد & دارد \\
\hline
		\end{tabular}
		\label{tab:cons}
	\end{center}
\end{table}


\subsubsection{\lr{Practical Byzantine Faul Tolerance}}

 در این روش در ابتدای رای‌گیری حوزه‌ها در یک زنجیره‌ی اولویت چیده می‌شوند و برای ثبت هر بلوک جدید، بلوک آماده‌شده را به رهبر (حوزه‌ای با بیشترین اولیت) داده می‌شود و حوزه آن‌ را به تمامی حوزه‌های دیگر ارسال می‌کند. سپس تمامی حوزه‌های دیگر بعد از تایید نتیجه را برای هم ارسال می‌کنند و در صورت موفقت آن را ثبت می‌کنند، بعد از تایید نتایج برای حوزه‌ی ابتدایی ارسال شده و ثبت نهایی می‌شود.
 \par
 همچنین بعد از اضافه شدن هر بلوک حوزه‌ی رهبر تغییر می‌کند و به نفر بعدی در زنجیره‌ی اولیت می‌رسد. همچنین در صورت جواب ندادن حوزه‌ی رهبر در مدت زمان مشخص یا جواب‌های غلط دادن مسئولیت به نفر بعدی منتقل می‌شود. 
 
 \begin{figure}[h!]
 	\centering
 	\includegraphics[width=1\linewidth]{PBFT.png}
 	\caption {روش \lr{PBFT}}
 	\label{fig:PBFT}
 \end{figure}
 
 \par
  در این روش حداکثر تعداد تعداد حوزه‌ای که باید خطاکار باشند تا بلوک اشتباهی در بلاک‌چین ثبت شود برای 
$3f + 1$
حوزه $f$ حوزه‌است.
 این تعداد حوزه‌ی خراب‌کار می‌توانند بلوک‌های اشتباهی ثبت کنند اما به دلیل استفاده از امضای دیجیتال بعد از اتمام رای‌گیری با بررسی درستی بلوک‌های ثبت شده در بلاک‌چین بلوک‌های خطا به سادگی قابل شناسیایی هستند. در همچین شرایطی چون نمی‌توان از تعداد رای‌دهندگانی که رای‌ آن‌ها ثبت نشده اطمینان پیدا کرد نتایج رای‌گیری باید مردود محسوب شود. 
 \par
 در روش \lr{PBFT} اثبات می‌شود 
 \cite{bftcap}
 تا زمانی که کمتر از یک سوم حوزه‌ها خطاکار باشند هیچ زمانی دو نسخه‌ی مستقل از بلاک‌چین توسط حوزه‌ها تایید نمی‌شود. به عبارت دیگر این روش به طور کامل هم‌خوانی و توانایی قسمت‌شدن را دارد.
 \par
 لازم به ذکر است که در این حالت سیستم همواره دردسترس نیست. به این معنی که ممکن است موقعیتی پیش بیاید که یک حوزه به دلیل قطع شدن شبکه از بقیه‌ی حوزه‌ها نتواند بلوک جدید ثبت کند، اما می‌تواند در بافر خود اطلاعات آرا را نگه دارد و زمان اتصال به شبکه بلوک جدید را بسازد و ثبت کند.
\cchapter{تحلیل و ارزیابی}
\section{پیاده سازی}
برای ساخت اثبات‌های بی‌دانش از کتاب‌خانه‌ی 
\lr{libsnark}\LTRfootnote{https://github.com/scipr-lab/libsnark}
استفاده شده است. این کتاب‌خانه از الگوریتم پینوکیو برای ساخت اثبات استفاده می‌کند و توسط \lr{Zcash} نیز برای ساخت اثبات استفاده شده است. همچنین برای بالا آوردن سیستم از \lr{docker} استفاده شده است. 
\par
در فرایند کامپایل این کتاب‌خانه از تنظیمات زیر استفاده شده است:
\begin{table}[h!]
	\begin{center}
		%		\def\arraystretch{2}
		\caption{تنظیمات \lr{libsnark}}
		\begin{tabular}{|c|c|c|}
			\hline
			نام متغیر& مقدار & توضیحات \\
			\hline
			CURVE & \lr{ALT\_BN128} & مدل خم مورد استفاده با ۱۲۸ بیت امنیت \\
			\hline
			MULTICORE & ON & استفاده از چند هسته برای موازی سازی \\
			\hline
			USE\_PT\_COMPRESSION & OFF & سرعت بالاتر در ازای حجم شاهدهای بزرگتر \\
			\hline
			PROFILE\_OP\_COUNTS & OFF & شمارش تعداد فعالیت روی خم 
			 \\
			 \hline
		\end{tabular}
		\label{tab:libsnark}
	\end{center}
\end{table}
\\
بقیه‌ی تنظیمات کتاب‌خانه در حالت پیش‌فرض استفاده شده است.
\par
برای بلاک‌چین و حوزه‌ها از 
\lr{hyperledger fabric} \LTRfootnote{https://www.hyperledger.org/projects/fabric}
که یک بستر قراردادهای هوشمند است استفاده شده است. 
\lr{hyperledger fabric}
توسط شرکت \lr{IBM} طراحی شده و توسط \lr{Linux Foundation} نگهداری می‌شود. این پروژه یک بلاک‌چین خصوصی ارائه می‌کند که قسمت‌های مختلف آن مانند روش توافق به سادگی قابل تغییرند.


\section{مقایسه با کارهای مشابه}
در این بخش به مقایسه‌‌ی روش رای‌گیری ارائه شده با تحقیقات دیگر در این زمینه می‌پردازیم . این مقایسه را از چند جنبه‌ی نحوه‌ی اطمینان از ثبت رای، ناشناسی آرا،  سطح اعتماد مورد نیاز و  هزینه‌ی انتخابات بررسی می‌کنیم. 
\subsection{روش‌های رای‌گیری دیگر}
برای مقایسه سیستم‌های رای‌گیری زیر را بررسی می‌کنیم:
\begin{itemize}
	\item 
	\textbf{رای‌گیری سنتی}:
	این روش به عنوان خط مبنای تحقیق بررسی می‌شود، در این روش از سیستم‌های الکترونیکی برای رای‌گیری استفاده نمی‌شود. این روش در بخش ۱.۲ توصیف شده است. 
	\item \textbf{رای‌‌گیری الکترونیک بدون بلاک‌چین}:
	در این روش، رای‌گیری الکترونیک متمرکز را بررسی می‌کنیم، چرا که سیستم‌های رای‌گیری توزیع‌شده‌ی بدون بلاک‌چین به به کاربرد عمومی نرسیدند. در این سیستم‌ها اطلاعات رای‌دهندگان و نتیجه‌ی رای آن‌ها به دلیل نیاز به روش ردگیری به طور کامل ثبت می‌شود اما در فرایند ثبت رای تفاوت چندانی با سیستم‌های سنتی ندارند.
 	\item \textbf{\lr{VoteBook}}
 	این سیستم را به عنوان مصداقی از سیستم‌های رای‌گیری با بلاک‌چین خصوصی بررسی می‌کنیم. 
 	در این سیستم از یک‌ بلاک‌چین که می‌توان در حالت خصوصی یا عمومی از استفاده کرد برای ثبت آرا استفاده می‌شود. 
\end{itemize}
\par
 	 سیستم‌ معروف \lr{VoteWatcher} نیز فعالیت‌های بسیاری در این زمینه داشته اما به دلیل عمومی نبودن اطلاعات پیاده‌سازی این سیستم‌، از مقایسه‌ی آن خود‌داری می‌کنیم. 
 	 \\
 	 همچنین از آن‌جایی که روش‌های رای‌گیری به کمک یک بلاک‌چین عمومی و یا روش‌های توزیع‌شده بدون بلاک‌چین به دلیل مشکلات مقیاس‌پذیری توانایی استفاده شدن در انتخابات‌های بزرگ(بیش از چند هزار نفر) را ندارند از بررسی این نوع سیستم‌ها صرف نظر می‌کنیم.
 	 \\
 	 همچنین روش مورد استفاده در \lr{Follow my Vote} از لحاظ روش پیاده‌سازی شباهت زیادی به \lr{VoteBook} دارد ولی به جای حوزه‌ی رای‌گیری از یک برنامه در کامپیتور شخصی یا تلفن هوشمند استفاده می‌کند. این تصمیم باعث سادگی فرایند رای‌گیری برای بعضی از رای‌دهندگان می‌شود اما دو مشکل بزرگ ایجاد می‌کند که باعث شده از مقایسه‌ی آن خودداری کنیم. اولین مشکل کاهش دسترسی‌پذیری این سیستم برای افرادی که دسترسی به اینترنت ندارند است و دومین مشکل این است که بدون وجود یک حوزه‌ی امن، راهی وجود ندارد تا اطمینان حاصل کنیم که رای‌دهنده مجبور به رای‌دادن به کاندیدای خاصی نشده است.
\subsection{اطمینان از شمارش درست}
شاید مهمترین شرط برگذاری یک انتخابات میزان اطمینان از شمارش درست آرا در آن‌ باشد. در این بخش به بررسی نجوه‌ی شمارش آرا در روش‌های مختلف می‌پردازیم. 
\par
در روش سنتی برای شمارش آرا بعد از اتمام انتخابات برگه‌های رای‌ موجود در صندوق‌ها به مکانی منتقل می‌شوند و در آن‌ جا یا به روش انسانی و یا با استفاده از دستگاه‌های الکترونیکی شمارش می‌شوند. طبیعتا این مدل شمارش به دلیل دخالت انسانی احتمال خطای نسبتا بالایی دارد. همچنین برای اطمینان درستی شمارش یک حوزه، تنها روش شمارش کامل برگه‌های رای‌ آن حوزه است که هزینه‌ی آن معادل هزینه شمارش اولیه می‌باشد. 
\par 
در روش‌های رای‌گیری بدون بلاک‌چین برای ثبت رای، اطلاعات کاربر به طور رمزشده به همراه نتیجه‌ی رای‌ او ثبت می‌شود. دلیل نگه‌داشتن اطلاعات رای‌دهنده توانایی رد‌گیری و بررسی درستی شمارش آرا است. در این سیستم‌ها شمارش رای‌گیری به صورت آنلاین اتفاق می‌افتد و هزینه‌ی چندانی ندارد، همچنین بررسی ناظر انتخابات هزینه‌ ناچیزی خواهد داشت. 
\par 
در سیستم \lr{VoteBook} و سیستم پیشنهادی این تحقیق نیز روال شمارش آرا تفاوت چندانی ندارد و هزینه‌ی اضافه‌ای برای شمارش آرا اضافه نمی‌کنند. اما در این دو روش با عمومی شدن بلاک‌چین قبل یا در حین رای‌گیری رای‌دهندگان نیز می‌توانند از درستی شمارش آرا و شمرده شدن رای خود اطمینان حاصل کنند. 
\subsection{حریم خصوصی}
در روش سنتی برگزاری انتخابات با توجه به ناشناس بودن برگه‌های رای در صندوق رای‌گیری راهی برای فهمیدن نتیجه‌ی رای‌ یک فرد خاص نیست. البته با توجه به این که حوزه‌ی رای‌گیری برگه‌های رای را از قبل از انتخابات در دسترس دارد، این گزاره در صورتی صحیح است که حوزه یا شماره یا علامتی ناشناسی برگه‌های رای را از بین نبرده باشد.
\par 
در روش‌های رای‌گیری الکترونیک بدون بلاک‌چین، با توجه به عمومی نشدن اطلاعات رای‌گیری اطلاعات محفوظ می‌مانند. در این روش نیز حوزه‌ی انتخابات که مسئولیت رمزکردن اطلاعات شخصی کاربر را دارد می‌تواند به حریم خصوصی آسیب بزند. همچینین برای جلوگیری از دو بار رای دادن یک کاربر باید مرکز مستقلی که اطلاعات رای‌گیری را ذخیره می‌کند نیز توانایی بازگشایی اطلاعات کاربر را داشته باشد در نتیجه این مرکز و تمامی افرادی که به اطلاعات آن دسترسی دارند نیز می‌توانند حریم خصوصی را نقض کنند. 
\par
در روش \lr{VoteBook} هر رای‌دهنده یک «شماره‌ی رای‌دهنده» دارد و بعد از رای دادن نیز یک «شماره‌ی رای» دریافت می‌کند. در ادامه هش شماره‌ی رای و شماره‌ی راه‌دهنده در بلاک‌چین به عنوان رای‌دهنده ثبت می‌شود. در این روش علاوه بر حوزه، هر کسی که شماره‌ی رای و شماره‌ی رای‌دهنده را داشته باشد می‌تواند از نتیجه‌ی رای آن فرد آگاه شود. شماره‌های رای‌دهندگان در یک بلاک‌چین خصوصی مستقل نگهداری می‌شود و هیچ وقت عمومی نمی‌شوند در نتیجه جدا از حوزه‌ی رای‌گیری فقط خود فرد (یا کسی که اطلاعات خصوصی او را از خودش دریافت کند) می‌تواند نتیجه‌ی رای فرد را بررسی کند. 
\par 
در روش پیشنهادی ما برای از بین بردن ریسک لو رفتن اطلاعات درست ثبت شدن رای در خود حوزه به کاربر اثبات می‌شود و چون خود کاربر تراکنش ثبت را کورکورانه امضا می‌کند بعد از فرایند ثبت رای راهی برای پیدا کردن نتیجه‌ی رای فرد وجود ندارد. در این روش نیز مانند همه‌ی روش‌های ممکن در رای‌گیری حوزه‌ی خطاکار می‌تواند در حین دریافت رای نتیجه‌ی آن را جداگانه ثبت کند و از این روش به حریم خصوصی آسیب بزند اما با توجه به این که تمامی بلوک‌ها توسط حوزه‌ها امضا شده‌اند در صورت نقض حریم خصوصی به سادگی حوزه‌ی خطاکار مشخص می‌شود.

\subsection{هزینه برگزاری}
در این بخش هزینه‌ی برگزاری انتخابات با هر کدام از روش‌ها را از دید کاربر و از دید مجری انتخابات بررسی می‌کنیم.
\subsubsection{هزینه برای کاربر}
فرایند رای‌دادن کاربر در روش‌هایی که بررسی می‌کنیم به سه حالت خواهد بود:
\begin{itemize}
 \item 
 در روش‌ سنتی و رای‌گیری بدون بلاک‌چین کاربر برای رای‌دادن صرفا نیاز کارت شناسایی دارد. کاربر با ارائه‌ی کارت شناسایی و بعد از بررسی شدن این که کاربر دو بار رای نداده رای خود را ثبت می‌کند. 
 \item 
 در رای‌گیری با بلاک‌چین با هدف افزایش شفافیت و ایجاد اطمینان از شمارش درست آرا برای کاربر، هر کابری نیاز به ثبت یک «هویت یکتا» در سامانه‌ی مربوط به انتخابات دارد. در \lr{VoteBook} این کار با شماره‌ی رای‌‌دهنده اتفاق می‌افتد و همچنین کاربر باید قبل از رای‌ دادن حوزه‌ی مد نظر خود را برای رای‌دادن مشخص کند. دلیل مشخص کردن حوزه این است که شماره‌ی رای‌دهندگان ممکن از قبل در حوزه ذخیره شده باشند.
 
 \item
 در سیستم ما نیز کاربر باید قبل از رای‌گیری یک کلید عمومی ثبت کند که برای فرایند رای‌گیری استفاده می‌شود. همچنین کاربر برای اطمینان از درست شمرده شدن رای خود می‌تواند از یک دستگاه هوشمند برای عمل امضای کورکورانه استفاده کند. کاربر می‌تواند از دستگاه‌های درون حوزه استفاده کند ولی با این کار باید اعتماد کند که حوزه رایش را به درستی ثبت کرده چرا که راهی برای اثبات درستی برنامه‌ی موجود در حوزه وجود ندارد.
 در ادامه فرایند مانند روش‌های 
\end{itemize}
\subsubsection{هزینه انتخابات برای مجری}
در روش سنتی انتخابات هزینه‌ی اولیه‌ای برای مجری ایجاد نمی‌شود اما در هر انتخابات جدا از هزینه‌ی ایجاد حوزه، هزینه‌ی تولید برگه‌ی رای فیزیکی و شمارش را باید تحمل کند. 
\\
در روش‌های رای‌گیری الکترونیک متمرکز جدا از حوزه هزینه‌ی اضافی معنی‌داری به مجری تحمیل نمی‌شود، اما دستگا‌ه‌های الکترونیکی نیازمند بررسی و ارتقا در طول زمان هستند.
\\
در \lr{VoteBook} یک سامانه‌ای برای ثبت و نگهداری اطلاعات محل رای‌گیری و شماره رای‌دهنده برای هر کابر وجود دارد که خود این مسئله نیز نیازمند بررسی امنتی مداوم و ارتقا است. 
\\
در سیستم پیشنهادی ما نیز در هر انتخابات، مجری انتخابات باید توانایی عوض کردن یا ثبت کلید عمومی جدید را به رای‌دهندگان بدهد که خود این مسئله یک هزینه‌ی نگهداری به مجری اضافه می‌کند. 
\subsection{توانایی ردگیری خطا}
برای درستی انتخابات نیاز است که برای ناظر انتخابات راهی وجود داشته باشد تا از درستی برگزاری انتخابات اطمینان حاصل کند. با توجه به این که یک حوزه‌ی انتخابات خطاکار همواره می‌تواند بعضی رای‌ها را شمارش نکند و یا تلاش کند که رای جعلی تولید کند، در این بخض توانایی ردگیری همچین حملاتی را بررسی می‌کنیم.
در روال سنتی رای‌گیری با توجه به کاغذی بودن آرا و وصل نبودن برگه‌ی رای به کاربر، فراتر از بررسی تعداد آرا و مقایسه‌ی آن‌ها با تعداد برگه‌ی ثبت رای راهی برای بررسی درستی نتایج حوزه وجود ندارد. ایجاد برگه‌ رای‌های غلط هزینه‌ی اندکی ندارد ولی در انتخابات‌های حساس ممکن است به صرفه باشد و در صورت اتفاق افتادن همچین مسئله‌ای، راه‌حل سیستمی برای پیدا کردن مشکل وجود ندارد. همچینین در صورتی که بخشی از آرا توسط حوزه دور ریخته شود، ناظر انتخابات هیچ راهی برای فهمیدن این عمل ندارد و رای‌دهندگان عادی نیز روش برای فهمیدن این موضوع که رای آن‌ها شمارده نشده ندارند.
\par 
در سیستم‌های رای‌گیری الکترونیک بدون بلاک‌چین نیز رای‌دهنده راهی برای اطمینان حاصل کردن رای‌‌دهنده از شمارش رایش وجود ندارد. همچنین راهی برای ناظر انتخابات برای تشخیص دادن رای‌هایی که فرستاده نشده‌اند وجود ندارد. با توجه به این که کاربر برای ارسال رای هیچ راه شناسایی مستقل از حوزه‌ای هم ندارد، ایجاد رای دروغین توسط حوزه هم ممکن است. 
\par 
در سیستم‌ \lr{VoteBook} برای ایجاد اطمینان از شمارش آرا تمامی رای‌ها شفاف ذخیره می‌شوند و هر کسی که با اطلاعات خصوصی خود می‌تواند بررسی کند که رای او به درستی ثبت شده است. ناظر انتخابات نیز می‌تواند رای‌های ثبت شده را با اطلاعات کاربرانی که باید در آن حوزه رای می‌دادند بررسی کند و به این صورت هیچ رای اشتباهی نمی‌تواند ثبت شود. اما یک حمله‌ای که حوزه‌ی خراب‌کار می‌تواند انجام دهد این است که رای کاربر را به عنوان رای ممتنع ثبت کند. در فرایند رای‌گیری با \lr{VoteBook} از کاربر پرسیده می‌شود که تحت فشار مجبور به رای دادن شده یا خبر، در صورت پاسخ بله کاربر شماره‌ی رای کاربر به عنوان رای ممتنع ثبت می‌شود و اطلاعات آرا ممتنع هیچ‌وقت به صورت عمومی منتشر نمی‌شوند اما با توجه به این که این اطلاعات در اختیار ناظر انتخابات خواهد بود حمله‌‌ی بزرگ به این روش به سادگی قابل تشخیص خواهد بود. 
\par 
در سیستم رای‌گیری ما نیز کاربر از درستی شمارش رای‌ ثبت‌شده‌ی خود در فرایند امضای کورکورانه آگاه می‌شود همچنین بعد از فرایند رای‌گیری نیز می‌تواند با بررسی بلاک‌چین از ثبت رای‌ خود (ولی نه نتیجه‌ی آن) مطمئن شود. از آن‌جایی که تمامی رای‌ها نیازمند امضای دیجیتال رای‌دهندگان هستند راهی برای ایجاد رای‌های دروغین توسط یک حوزه نیز وجود ندارد. از طرفی ناظر انتخابات می‌تواند با بررسی تساوی تعداد تراکنش‌ها ثبت و شمارش ثبت شده در بلاک‌چین رفتار حوزه را تحلیل کند. در صورت پیدا کردن خطا از یک حوزه راهی برای پیدا کردن کاربری که رای او شمرده نشده و نتیجه‌ی رای او نخواهد بود. 

\section{نزدیکی به رای‌گیری ایده‌آل}
در این بخش به بررسی نزدیکی پروتکل رای‌گیری ارائه شده با رای‌گیری ایده‌آل می‌پردازیم. 

\begin{itemize}
	\item 
	می‌دانیم که هر شخصی حداکثر یک رای‌ می‌تواند بدهد چون که در حساب کلید عمومی آن فرد دقیقا یک رای در ابتدای رای‌گیری وجود دارد. از طرفی می‌دانیم که سیستم مانع رای دادن فردی نمی‌شود چرا که رای‌دهنده می‌تواند بررسی کند که رای‌ او در بلاک‌چین مصرف شده باشد.
	\item 
	می‌دانیم کسی نمی‌تواند به جای دیگری رای دهد، چرا که برای رای دادن هم نیاز به دسترسی به کلیدخصوصی دارد و هم کلید عمومی فرد با اطلاعات شناسایی او در حوزه مقایسه می‌شود.
	\item 
	با اضافه شدن گزینه‌ی ممتنع و حفظ امنیت فیزیکی حوزه‌ی رای‌گیری می‌توانیم اطمینان حاصل کنیم که کسی مجبور به رای‌ دادن نمی‌شود.
	\item 
	هیچ فردی مجبور به رای دادن به کاندیدای خاصی نشود. با توجه به امنیت فیزیکی رای‌گیری و ناشناسی آرا می‌توانیم مطمئن باشیم که کسی مجبور به انتخاب گزینه‌ی خاصی نمی‌شود.
	\item 
	در انتهای انتخابات می‌توانیم به سادگی با بررسی تعداد تراکنش‌های ثبت و شمارش از درستی شمارش آرا اطمینان حاصل کنیم. در صورت شمارده نشدن یک رای می‌توان فرد رای‌ دهنده و حوزه را پیدا کرد اما راهی برای فهمیدن نتیجه‌ی رای فرد وجود ندارد.
	\item 
	نتیجه‌ی آرا ناشناس  باقی بماند. از آن‌جایی که تراکنش‌های ثبت کورکورانه امضا می‌شوند حتی خود رای‌دهنده با وجود از اطمینان از نتیجه‌ی رای راهی برای چک کردن نتیجه‌ی برگه‌ی رایش بعد از انتخابات ندارد.
	\item 
	بسته به نیاز بتوان نتایج لحظه‌ای انتخابات را (بدون آسیب به شرط‌های قبلی) دید.
\end{itemize}


\section{معیار‌های مقایسه}
برای مقایسه این روش رای گیری با روش‌های دیگر جنبه‌های زیر را بررسی می‌کنیم:
\begin{itemize}
	\item
	هزینه‌ی زیرساخت
	\item
	هزینه‌ی هر رای‌گیری
	\item 
	توانایی ردگیری درستی رای‌گیری
	\item
	هزینه برای کاربر
	\item
	درصد اطمینان از درست شمارده شدن رای 
	\item 
	توانایی بررسی ناظر انتخابات
	\item 
	سختی مجبور کردن یک کاربر برای رای دادن به یک کاندیدای خاص
\end{itemize}

